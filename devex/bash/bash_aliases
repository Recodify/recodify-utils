#----------------------------LS----------------------------------------

# long listing, all files (including dotfiles), classify types, human-readable
alias ll='ls -alFh'
# show all files except . and .. (good for quick scans)
alias la='ls -A'
# long listing, sorted by modified time, newest first, human-readable
alias lt='ls -lth'
# long listing, sorted by modified time, oldest first, human-readable
alias ltr='ls -ltrh'

# lsf - list first file/directory matching pattern
# Usage: lsf [pattern]
# Examples:
#   lsf           # first item in current dir
#   lsf *.log     # first .log file
#   lsf -t        # first item sorted by modification time
lsf() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: lsf [ls options] [pattern]"
        echo "Show the first file/directory from ls output"
        echo ""
        echo "Examples:"
        echo "  lsf              # first item in current dir"
        echo "  lsf *.log        # first .log file"
        echo "  lsf -t           # first item sorted by modification time"
        return 0
    fi
    ls "$@" | head -n 1
}

#----------------------------Cat----------------------------------------


# catf - cat the first file matching pattern
# Usage: catf [pattern]
# Examples:
#   catf *.txt    # cat the first .txt file
#   catf *.json   # cat the first .json file
catf() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: catf [ls options] [pattern]"
        echo "Cat the first file from ls output"
        echo ""
        echo "Examples:"
        echo "  catf *.txt       # cat the first .txt file"
        echo "  catf *.json      # cat the first .json file"
        return 0
    fi
    
    local file
    file=$(ls "$@" | head -n 1)
    
    if [[ -z "$file" ]]; then
        echo "Error: no files found" >&2
        return 1
    elif [[ ! -f "$file" ]]; then
        echo "Error: '$file' is not a regular file" >&2
        return 1
    fi
    
    cat "$file"
}

# catl - cat the latest (most recently modified) file matching pattern
# Usage: catl [pattern]
# Examples:
#   catl *.log    # cat the most recent .log file
#   catl          # cat the most recent file in current dir
catl() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: catl [pattern]"
        echo "Cat the most recently modified file"
        echo ""
        echo "Examples:"
        echo "  catl *.log       # cat the most recent .log file"
        echo "  catl             # cat the most recent file in current dir"
        return 0
    fi
    
    local file
    file=$(ls -t "$@" | head -n 1)
    
    if [[ -z "$file" ]]; then
        echo "Error: no files found" >&2
        return 1
    elif [[ ! -f "$file" ]]; then
        echo "Error: '$file' is not a regular file" >&2
        return 1
    fi
    
    cat "$file"
}

#------------------------------GIT---------------------------------------
alias rmorig="find . -name '*.orig' -delete"
# untrack ignored files without deleting them
alias git-untrack='git rm -r --cached . && git add .'

# short status
alias gs='git status -sb'

# diff status
alias gsv='git status -vv'

# last commit, readable
alias gl='git log -1 --oneline --decorate'

# compact log graph
alias glg='git log --oneline --decorate --graph --all'

# list untracked and unignore files in size desc order
alias gitxl='git ls-files -o --exclude-standard | xargs du -h | sort -h'



#---------------------------SYMLINKS-----------------------------------
# create symlink with clear syntax: symlink <target> <link_name>
# Example: symlink /usr/bin/python3 /usr/local/bin/python
lnthere() {
  if [ $# -ne 2 ]; then
    echo "Usage: symlink <target> <link_name>"
    echo "Creates: link_name -> target"
    echo ""
    echo "Examples:"
    echo "  symlink /usr/bin/python3 ~/bin/python"
    echo "  symlink /opt/app/config.json ./config.json"
    return 1
  fi
  ln -s "$1" "$2"
  echo "Created: $2 -> $1"
  ls -l "$2"
}

# create symlink to file/dir in current directory
# Example: lnhere /etc/nginx/sites-available/mysite
lnhere() {
  if [ -z "$1" ]; then
    echo "Usage: lnhere <target>"
    echo "Creates symlink in current directory with same name as target"
    echo ""
    echo "Example: lnhere /etc/nginx/sites-available/mysite"
    echo "Creates: ./mysite -> /etc/nginx/sites-available/mysite"
    return 1
  fi
  local target="$1"
  local name=$(basename "$target")
  ln -s "$target" "$name"
  echo "Created: $name -> $target"
  ls -l "$name"
}

# show where a symlink points (resolves full path)
# Example: wherelinks /usr/bin/python
alias lnwherea='readlink -f'

# show where symlink points (one level, doesn't resolve further)
alias lnwhere='readlink'

# list all symlinks in current directory
alias lnls='find . -maxdepth 1 -type l -ls'

# list all symlinks recursively
alias lslinksall='find . -type l -ls'

# find broken symlinks in current directory
alias lnfindbroken='find . -maxdepth 1 -xtype l'

# find all broken symlinks recursively
alias lnfindbrokenall='find . -xtype l'

alias lnrm='unlink'

# remove broken symlinks in current directory
lnrmbroken() {
  local broken=$(find . -maxdepth 1 -xtype l)
  if [ -z "$broken" ]; then
    echo "No broken symlinks found"
    return 0
  fi
  echo "Found broken symlinks:"
  echo "$broken"
  echo ""
  read -p "Remove these broken symlinks? (y/N) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    find . -maxdepth 1 -xtype l -delete
    echo "Removed broken symlinks"
  else
    echo "Cancelled"
  fi
}

# show symlink details (target, type, size)
lninfo() {
  if [ -z "$1" ]; then
    echo "Usage: lninfo <symlink>"
    return 1
  fi
  if [ ! -L "$1" ]; then
    echo "Error: $1 is not a symlink"
    return 1
  fi
  echo "Symlink: $1"
  echo "Points to: $(readlink "$1")"
  echo "Resolves to: $(readlink -f "$1")"
  echo ""
  ls -lh "$1"
  echo ""
  if [ -e "$1" ]; then
    echo "Target exists: ✓"
    file "$(readlink -f "$1")"
  else
    echo "Target exists: ✗ (broken symlink)"
  fi
}


#---------------------------FILE SYSTEM--------------------------------
# ncdu, stay on same filesystem
alias ncdu1='ncdu -x .'

# human-readable du, one level deep
alias duh='du -h --max-depth=1'

# count lines in files: lcount *.ts *.js
#alias lcount='wc -l'
alias ss='gnome-screenshot -a -c'

lcount() {
  local src="$1"
  local pattern="$2"
  local maxDepth="${3:-1}"

  find "$src" -maxdepth "$maxDepth" -type f -iname "$pattern" -print0 \
  | xargs -0 wc -l \
  | awk 'NF==2 {s+=$1} END{printf "%.0f\n", s}'
}

csv_wc_count_int() {
  local dir="${1:-.}"
  [[ -d "$dir" ]] || { echo "csv_wc_count_int: not a directory: $dir" >&2; return 1; }

  local file_count total_lines rows
  file_count=$(find "$dir" -maxdepth 1 -type f -name '*.csv' -print | wc -l)
  [[ "$file_count" -eq 0 ]] && { printf '0\n'; return 0; }

  total_lines=$(
    find "$dir" -maxdepth 1 -type f -name '*.csv' -print0 \
      | xargs -0 wc -l \
      | awk 'END{print $1}'
  )

  rows=$(( total_lines - file_count ))
  (( rows < 0 )) && rows=0
  printf '%d\n' "$rows"
}

# Count total CSV data rows in a directory (assumes 1 header row per file)
csv_wc_count() {
  local dir="${1:-.}"

  if [[ ! -d "$dir" ]]; then
    echo "csv_wc_count: not a directory: $dir" >&2
    return 1
  fi

  local oldpwd total_lines file_count
  oldpwd="$(pwd)"

  cd "$dir" || return 1

  file_count=$(find . -maxdepth 1 -type f -name '*.csv' -print | wc -l)

  if [[ "$file_count" -eq 0 ]]; then
    echo "Dir: $dir"
    echo "Total data rows: 0"
    echo "Total files: 0"
    cd "$oldpwd" || true
    return 0
  fi

  total_lines=$(
    find . -maxdepth 1 -type f -name '*.csv' -print0 \
      | xargs -0 wc -l \
      | awk 'END{print $1}'
  )

  echo "Dir: $dir"
  echo "Total data rows: $((total_lines - file_count))"
  echo "Total files: $file_count"

  cd "$oldpwd" || true
}

# Count total rows across Parquet files in a directory using DuckDB
parquet_duck_count() {
  local dir="${1:-.}"

  if [[ ! -d "$dir" ]]; then
    echo "parquet_duck_count: not a directory: $dir" >&2
    return 1
  fi

  # Count files first, and bail out before touching duckdb if none exist
  local file_count
  file_count=$(find "$dir" -maxdepth 1 -type f -name '*.parquet' -print | wc -l)

  if [[ "$file_count" -eq 0 ]]; then
    echo "Dir: $dir"
    echo "Total rows: 0"
    echo "Total files: 0"
    return 0
  fi

  if ! command -v duckdb >/dev/null 2>&1; then
    echo "parquet_duck_count: duckdb not found on PATH" >&2
    return 1
  fi

  echo "Dir: $dir"
  duckdb -c "SELECT COUNT(*) AS rows FROM read_parquet('${dir%/}/*.parquet');"
  echo "Total files: $file_count"
}


mvx() {
  local src="$1"
  local dest="$2"
  local pattern="$3"
  local maxDepth="${4:-1}"
  local type="${5:-f}"

  find "$src" -maxdepth "$maxDepth" -type "$type" -iname "$pattern" -exec mv -t "$dest" -- {} +
}


cpx() {
  local src="$1"
  local dest="$2"
  local pattern="$3"
  local maxDepth="${4:-1}"
  local type="${5:-f}"

  find "$src" -maxdepth "$maxDepth" -type "$type" -iname "$pattern" -exec cp -t "$dest" -- {} +
}


# Count files recursively, with optional path + max depth.
# Usage:
#   fcount                # current dir, depth 0 (only ./)
#   fcount . 2            # current dir, depth 2
#   fcount /var/log 1     # /var/log, depth 1
fcount() {
  local path="${1:-.}"
  local depth="${2:-1}"

  if ! [[ "$depth" =~ ^[0-9]+$ ]]; then
    echo "Usage: fcount [path] [max_depth]"
    echo "max_depth must be a non-negative integer"
    return 1
  fi

  find "$path" -maxdepth "$depth" -type f 2>/dev/null | wc -l
}

# Count files by extension or pattern, with optional path + max depth.
# Usage:
#   fcountx '*.json'              # current dir, depth 0
#   fcountx '*.json' . 3          # current dir, depth 3
#   fcountx '*.json' /tmp 2       # /tmp, depth 2
fcountx() {
  local pattern="$1"
  local path="${2:-.}"
  local depth="${3:-1}"

  if [ -z "$pattern" ]; then
    echo "Usage: fcountx <pattern> [path] [max_depth]"
    echo "Example: fcountx '*.json' . 3"
    return 1
  fi

  if ! [[ "$depth" =~ ^[0-9]+$ ]]; then
    echo "Usage: fcountx <pattern> [path] [max_depth]"
    echo "max_depth must be a non-negative integer"
    return 1
  fi

  find "$path" -maxdepth "$depth" -type f -name "$pattern" 2>/dev/null | wc -l
}

stat-count() {
  c=$(fcount $1)
  echo "$1 $c"
}

#----------------------------DOCKER------------------------------------
# list all running containers with better formatting
alias dockerps='docker ps --format "{{.Names}}\t\t{{.Status}}"'
# stop all running containers
alias dockerstopall='docker stop $(docker ps -a -q)'

d-restart() {
  d-down && d-up
}
#----------------------------TEXT--------------------------------------
# strip ANSI escape codes (color codes etc) from text
alias stripansi='sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g"'
# recursive grep, line numbers, ignore binary junk
alias gr='grep -RIn --binary-files=without-match'

# grep but ignore the usual garbage (ignores common build/dependency dirs)
alias grc='grep -RIn --binary-files=without-match --exclude-dir={.git,node_modules,dist,build,target,.venv}'

#------------------------------AWS-------------------------------------
alias aws2='/home/sam/aws-cli2/v2/current/bin/aws'


#----------------------------PYTHON------------------------------------
alias python='python3'
alias python2='/bin/python'
alias pymkenv='python -m venv ./venv'
alias pyenv='. ./venv/bin/activate'


#----------------------------TERRAFORM---------------------------------
alias tf=terraform

#----------------------------MOUNTS & DISKS----------------------------
# show all mounts in a tree view
alias mounts='findmnt'

# show mounts with filesystem type and size, human-readable
alias mountsdf='df -hT'

# show only local physical mounts (no tmpfs, devtmpfs, etc)
alias mountsreal='findmnt -t ext4,ext3,xfs,btrfs,ntfs'

# check what's mounted at a specific point
alias mountat='findmnt --target'

# list all block devices with filesystem info
alias lsb='lsblk -f'

# list block devices with size, type, mountpoints
alias lsblkall='lsblk -o NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT,UUID'

# disk usage by filesystem
alias dfh='df -hT --exclude-type=tmpfs --exclude-type=devtmpfs'


#----------------------------SYSTEMCTL---------------------------------
# list all running services
alias sysrunning='systemctl list-units --type=service --state=running'

# list all failed services
alias sysfailed='systemctl list-units --type=service --state=failed'

# list enabled services
alias sysenabled='systemctl list-unit-files --type=service --state=enabled'

# show full service status (no pager truncation)
alias sysstat='systemctl status --no-pager -l'

# restart a service and show its status
alias sysrestart='systemctl restart'

# reload systemd daemon (after editing unit files)
alias sysdaemon='systemctl daemon-reload'

# list all timers
alias systimers='systemctl list-timers --all'


#----------------------------DMESG & KERNEL----------------------------
# human-readable kernel messages with timestamps
alias dmesgh='dmesg -H'

# follow kernel messages in real-time
alias dmesgf='dmesg -w'

# show only errors and warnings
alias dmsgerr='dmesg -l err,warn'

# search dmesg for a pattern (use: dmsgg usb)
alias dmsgg='dmesg | grep -i'

# last 50 kernel messages, human-readable
alias dmesg50='dmesg -H | tail -50'


#----------------------------JOURNALCTL--------------------------------
# follow system journal in real-time
alias jf='journalctl -f'

# show journal for current boot only
alias jboot='journalctl -b'

# show journal for previous boot
alias jboot-1='journalctl -b -1'

# journal errors from current boot
alias jerr='journalctl -b -p err'

# journal for specific service (use: jsvc nginx)
alias jsvc='journalctl -u'

# follow specific service logs (use: jfollowsvc nginx)
alias jfollowsvc='journalctl -fu'

# show journal with full output (no truncation)
alias jfull='journalctl --no-pager -l'

# last 100 journal entries, human-readable
alias j100='journalctl -n 100 --no-pager'

# journal since 1 hour ago
alias j1h='journalctl --since "1 hour ago"'

# journal from today
alias jtoday='journalctl --since today'

# journal from yesterday
alias jyesterday='journalctl --since yesterday --until today'

# kernel messages from journal (alternative to dmesg)
alias jkernel='journalctl -k'

# vacuum old journal logs (keep last 7 days)
alias jvacuum='journalctl --vacuum-time=7d'


#----------------------------PROCESSES---------------------------------
# find process by name
alias psg='ps aux | grep -v grep | grep -i -e VSZ -e'

# top processes by memory usage
alias topmem='ps aux --sort=-%mem | head -n 11'

# top processes by CPU usage
alias topcpu='ps aux --sort=-%cpu | head -n 11'

ls-pid() {
  # pgrep gives you exactly what you want without grep noise
  pgrep -af $1 || true
}

run_n_times() {
  local n="$1"
  shift

  for ((i=1; i<=n; i++)); do
    "$@"
  done
}


run_n_times_bg() {
  local n="$1"
  shift

  pids=()

  for ((i=1; i<=n; i++)); do
    "$@" > /dev/null 2>&1 &
    #"$@" &
    pids+=($!)
  done
}

#----------------------------NETWORK-----------------------------------
# show listening ports with process names
alias ports='netstat -tulpn'

# alternative: listening ports with ss (faster)
alias portss='ss -tulpn'

# show all connections
alias conns='ss -tupan'

# list all open files with numeric UIDs
alias lsofl='lsof -l'

# list open files by specific user (use: lsofuser sam)
alias lsofuser='lsof -u'

# kill process listening on specific port (use: killport 8080)
killport() {
  if [ -z "$1" ]; then
    echo "Usage: killport <port_number>"
    return 1
  fi
  lsof -t -i ":$1" | xargs -r kill
}

# forcefully kill process on port (use: killport9 8080)
killport9() {
  if [ -z "$1" ]; then
    echo "Usage: killport9 <port_number>"
    return 1
  fi
  lsof -t -i ":$1" | xargs -r kill -9
}

# show what's using a specific port (use: whatport 8080)
alias whatport='lsof -i :'


#----------------------------SYSTEM INFO-------------------------------
# show OS/distribution version info
alias osinfo='lsb_release -a'

# show kernel version
alias kernelver='uname -r'


#----------------------------QUICK UTILS-------------------------------
# reload bash aliases without logging out
alias reload='source ~/.bashrc'

# show command history with timestamps
alias histt='history | tail -20'

# clear screen and show only current directory
alias cls='clear && pwd && ls'

# human-readable memory info
alias meminfo='free -h'

# watch command with 1 second interval
alias watch1='watch -n 1'

#----------------------------TAR & ARCHIVES----------------------------
# create tar.gz archive: targz archive-name.tar.gz folder/
alias targz='tar -czf'

# extract tar.gz: untargz archive.tar.gz
alias untargz='tar -xzf'

# create tar (no compression): tarcreate archive.tar folder/
alias tarcreate='tar -cf'

# extract tar: tarextract archive.tar
alias tarextract='tar -xf'

# list contents of tar: tarlist archive.tar.gz
alias tarlist='tar -tzf'

# extract tar.gz to specific directory: tarextractto archive.tar.gz /path/to/dir
alias tarextractto='tar -xzf'

# create tar.bz2 (better compression): tarbz archive.tar.bz2 folder/
alias tarbz='tar -cjf'

# extract tar.bz2: untarbz archive.tar.bz2
alias untarbz='tar -xjf'

# smart extract (auto-detects format): tarx archive.tar.*
alias tarx='tar -xf'

# create tar.gz with verbose output
alias targzv='tar -czvf'

# extract tar.gz with verbose output
alias untargzv='tar -xzvf'
